odoo.define("pos_ticket_invoice_customer", function (require) {
    var models = require("point_of_sale.models");
    var rpc = require('web.rpc');
    var screens = require('point_of_sale.screens');

    screens.PaymentScreenWidget.include({
        finalize_validation: function () {
            var self = this;
            var order = this.pos.get_order();
            if (order.is_paid_with_cash() && this.pos.config.iface_cashdrawer) {

                this.pos.proxy.open_cashbox();
            }
            order.initialize_validation_date();
            order.finalized = true;
            if (order.is_to_invoice()) {
                var invoiced = this.pos.push_and_invoice_order(order);
                this.invoicing = true;

                invoiced.fail(this._handleFailedPushForInvoice.bind(this, order, false));

                invoiced.done(function (orderId) {
                    self.invoicing = false;
                    rpc.query({
                        model: 'pos.order',
                        method: 'get_invoice_number',
                        args: [orderId],
                    })
                    .then(function (number) {
                        var order = self.pos.get_order();
                        order.invoice_number = number;
                        self.gui.show_screen('receipt');
                    });
                });
            } else {
                this.pos.push_order(order);
                this.gui.show_screen('receipt');
            }
        },
    });

    // var _superPosModel = models.PosModel.prototype;
    models.PosModel = models.PosModel.extend({
        push_and_invoice_order: function (order) {
            var self = this;
            var invoiced = new $.Deferred();
            if (!order.get_client()) {
                invoiced.reject({ code: 400, message: 'Missing Customer', data: {} });
                return invoiced;
            }
            var order_id = this.db.add_order(order.export_as_JSON());

            this.flush_mutex.exec(function () {
                var done = new $.Deferred(); // holds the mutex

                // send the order to the server
                // we have a 30 seconds timeout on this push.
                // FIXME: if the server takes more than 30 seconds to accept the order,
                // the client will believe it wasn't successfully sent, and very bad
                // things will happen as a duplicate will be sent next time
                // so we must make sure the server detects and ignores duplicated orders

                var transfer = self._flush_orders([self.db.get_order(order_id)], { timeout: 30000, to_invoice: true });

                transfer.fail(function (error) {
                    invoiced.reject(error);
                    done.reject();
                });

                // on success, get the order id generated by the server
                transfer.pipe(function (order_server_id) {

                    // generate the pdf and download it
                    if (order_server_id.length) {
                        self.chrome.do_action('point_of_sale.pos_invoice_report', {
                            additional_context: {
                                active_ids: order_server_id,
                            }
                        }).done(function () {
                            invoiced.resolve(order_server_id);
                            done.resolve();
                        }).fail(function (error) {
                            invoiced.reject({ code: 401, message: 'Backend Invoice', data: { order: order } });
                            done.reject();
                        });
                    } else {
                        // The order has been pushed separately in batch when
                        // the connection came back.
                        // The user has to go to the backend to print the invoice
                        invoiced.reject({ code: 401, message: 'Backend Invoice', data: { order: order } });
                        done.reject();
                    }
                });
                return done;
            });
            return invoiced;
        },
    });
});
